========== ./sqliteTests/sqliteTests.swift ==========
//
//  sqliteTests.swift
//  sqliteTests
// 
//  Created by Mordecai Mengesteab on 5/25/25.
//

import Testing
@testable import sqlite

struct sqliteTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}
import XCTest


class EmbeddingServiceTests: XCTestCase {
    
    var embeddingService: EmbeddingService!
    
    override func setUp() {
        super.setUp()
        // Initialize before each test
        // This will fail fast if service can't be created
        embeddingService = try! EmbeddingService()
    }
    
    override func tearDown() {
        embeddingService = nil
        super.tearDown()
    }
    
    // MARK: - Tokenization Tests
    
    func testEmptyStringTokenization() {
        // Logic: Empty strings shouldn't crash and should produce valid tokens
        // Common failure: tokenizer crashes on empty input or produces malformed output
        let tokenizer = try! BertTokenizer()
        let result = try! tokenizer.encode(text: "", maxLength: 512)
        
        XCTAssertEqual(result.inputIds.count, 512, "Should pad to max length")
        XCTAssertEqual(result.attentionMask.count, 512, "Attention mask should match")
        
        // Should have [CLS] and [SEP] tokens at minimum
        XCTAssertGreaterThan(result.attentionMask.prefix(10).reduce(0, +), 0, "Should have some real tokens")
    }
    
//    func testLongTextTruncation() {
//        // Logic: Very long text should be truncated gracefully without crashing
//        // Common failure: tokenizer fails on long inputs or produces wrong dimensions
//        let longText = String(repeating: "word ", count: 1000) // way over 512 tokens
//        let tokenizer = try! BertTokenizer()
//        let result = try! tokenizer.encode(text: longText, maxLength: 512)
//        
//        XCTAssertEqual(result.inputIds.count, 512, "Should truncate to max length")
//        XCTAssertEqual(result.attentionMask.count, 512, "Attention mask should match")
//        
//        // All tokens should be real (no truncation in middle of attention mask)
//        let realTokenCount = result.attentionMask.reduce(0, +)
//        XCTAssertEqual(realTokenCount, 512, "Should use all available tokens for long text")
//    }
    
    func testUnicodeTokenization() {
        // Logic: Unicode should be handled without crashing or corruption
        // Common failure: tokenizer mangles unicode or produces garbage tokens
        let unicodeText = "Hello üåç caf√© na√Øve ‰∏≠Êñá"
        let tokenizer = try! BertTokenizer()
        
        XCTAssertNoThrow(try tokenizer.encode(text: unicodeText, maxLength: 512),
                        "Unicode text should tokenize without crashing")
    }
    
    // MARK: - Embedding Consistency Tests
    
    func testSameTextSameEmbedding() async {
        // Logic: Identical input should always produce identical output
        // Critical for caching and reproducibility
        let text = "This is a test document"
        
        let embedding1 = try! await embeddingService.embed(text: text)
        let embedding2 = try! await embeddingService.embed(text: text)
        
        XCTAssertEqual(embedding1.count, embedding2.count, "Embeddings should have same length")
        
        // Compare each element (floating point comparison with tolerance)
        for i in 0..<embedding1.count {
            XCTAssertEqual(embedding1[i], embedding2[i], accuracy: 0.0001,
                          "Embedding values should be identical at index \(i)")
        }
    }
    
    func testEmptyStringEmbedding() async {
        // Logic: Empty string should produce valid embedding, not crash or return zeros
        // Common failure: model returns all zeros or crashes on empty input
        let embedding = try! await embeddingService.embed(text: "")
        
        XCTAssertEqual(embedding.count, 384, "Should produce correct dimension embedding")
        
        // Should not be all zeros (model should still output something meaningful)
        let magnitude = embedding.reduce(0) { $0 + $1 * $1 }
        XCTAssertGreaterThan(magnitude, 0.1, "Embedding should not be near-zero vector")
    }
    
    // MARK: - Vector Properties Tests
    
    func testEmbeddingDimensions() async {
        // Logic: All embeddings should have exactly 384 dimensions
        // Critical for database storage and vector search
        let texts = ["short", "medium length text", "This is a much longer piece of text that should still produce the same dimension output"]
        
        for text in texts {
            let embedding = try! await embeddingService.embed(text: text)
            XCTAssertEqual(embedding.count, 384, "Embedding for '\(text)' should be 384 dimensions")
        }
    }
    
    func testNoInvalidValues() async {
        // Logic: Embeddings should never contain NaN or infinite values
        // Common failure: model produces NaN on edge cases, breaks vector math
        let texts = ["", "normal text", "!!!", "123", "üéâüéâüéâ"]
        
        for text in texts {
            let embedding = try! await embeddingService.embed(text: text)
            
            for (i, value) in embedding.enumerated() {
                XCTAssertFalse(value.isNaN, "Value at index \(i) is NaN for text '\(text)'")
                XCTAssertFalse(value.isInfinite, "Value at index \(i) is infinite for text '\(text)'")
                XCTAssertTrue(value.isFinite, "Value at index \(i) is not finite for text '\(text)'")
            }
        }
    }
    
    func testReasonableValueRange() async {
        // Logic: Embedding values should be in reasonable range (typically -2 to 2)
        // Sanity check that model isn't producing garbage
        let embedding = try! await embeddingService.embed(text: "normal text")
        
        for (i, value) in embedding.enumerated() {
            XCTAssertGreaterThan(value, -10.0, "Value at index \(i) is unreasonably small: \(value)")
            XCTAssertLessThan(value, 10.0, "Value at index \(i) is unreasonably large: \(value)")
        }
    }
    
    // MARK: - Similarity Logic Tests
    
    func testIdenticalTextHighSimilarity() async {
        // Logic: Identical text should have very high similarity (cosine distance near 0)
        // Critical for search quality
        let text = "This is a test document"
        let embedding1 = try! await embeddingService.embed(text: text)
        let embedding2 = try! await embeddingService.embed(text: text)
        
        let similarity = cosineSimilarity(embedding1, embedding2)
        XCTAssertGreaterThan(similarity, 0.99, "Identical text should have >99% similarity")
    }
    
    func testRelatedTextSimilarity() async {
        // Logic: Related text should be more similar than unrelated text
        // This is the core functionality of your search
        let doc1 = "This is a document about dogs and puppies"
        let doc2 = "This document discusses cats and kittens"
        let unrelated = "The stock market closed higher today"
        
        let embed1 = try! await embeddingService.embed(text: doc1)
        let embed2 = try! await embeddingService.embed(text: doc2)
        let embedUnrelated = try! await embeddingService.embed(text: unrelated)
        
        let similarityRelated = cosineSimilarity(embed1, embed2)
        let similarityUnrelated1 = cosineSimilarity(embed1, embedUnrelated)
        let similarityUnrelated2 = cosineSimilarity(embed2, embedUnrelated)
        
        // Related animal docs should be more similar to each other than to stock market doc
        XCTAssertGreaterThan(similarityRelated, similarityUnrelated1,
                           "Related docs should be more similar than unrelated")
        XCTAssertGreaterThan(similarityRelated, similarityUnrelated2,
                           "Related docs should be more similar than unrelated")
    }
    
    func testKeywordOverlapSimilarity() async {
        // Logic: Docs with shared keywords should be more similar than completely different docs
        let doc1 = "machine learning algorithms"
        let doc2 = "artificial intelligence and machine learning"
        let unrelated = "cooking recipes for dinner"
        
        let embed1 = try! await embeddingService.embed(text: doc1)
        let embed2 = try! await embeddingService.embed(text: doc2)
        let embedUnrelated = try! await embeddingService.embed(text: unrelated)
        
        let similaritySharedKeywords = cosineSimilarity(embed1, embed2)
        let similarityUnrelated = cosineSimilarity(embed1, embedUnrelated)
        
        XCTAssertGreaterThan(similaritySharedKeywords, similarityUnrelated,
                           "Docs with shared keywords should be more similar")
    }
    
    // MARK: - Model Robustness Tests
    
    func testConcurrentEmbedding() async {
        // Logic: Multiple embedding requests shouldn't interfere with each other
        // Important for real app usage where user might trigger multiple searches
        let texts = ["text one", "text two", "text three", "text four"]
        
        await withTaskGroup(of: [Float].self) { group in
            for text in texts {
                group.addTask {
                    return try! await self.embeddingService.embed(text: text)
                }
            }
            
            var results: [[Float]] = []
            for await embedding in group {
                results.append(embedding)
                XCTAssertEqual(embedding.count, 384, "Concurrent embedding should have correct dimensions")
            }
            
            XCTAssertEqual(results.count, texts.count, "Should get embedding for each input")
        }
    }
    
    func testBatchProcessing() async {
        // Logic: Batch embedding should produce same results as individual embedding
        // Critical if you implement batch optimization later
        let texts = ["first text", "second text", "third text"]
        
        // Individual embeddings
        var individualEmbeddings: [[Float]] = []
        for text in texts {
            let embedding = try! await embeddingService.embed(text: text)
            individualEmbeddings.append(embedding)
        }
        
        // Batch embeddings
        let batchEmbeddings = try! await embeddingService.embed(texts: texts)
        
        XCTAssertEqual(individualEmbeddings.count, batchEmbeddings.count,
                      "Batch should produce same number of embeddings")
        
        for i in 0..<texts.count {
            let individual = individualEmbeddings[i]
            let batch = batchEmbeddings[i]
            
            XCTAssertEqual(individual.count, batch.count,
                          "Individual and batch embeddings should have same dimensions")
            
            // They should be identical (within floating point precision)
            for j in 0..<individual.count {
                XCTAssertEqual(individual[j], batch[j], accuracy: 0.0001,
                              "Individual and batch embeddings should be identical for text \(i), element \(j)")
            }
        }
    }
    
    // MARK: - Helper Functions
    
    /// Calculate cosine similarity between two embeddings
    /// Returns value between -1 and 1, where 1 is identical
    private func cosineSimilarity(_ a: [Float], _ b: [Float]) -> Float {
        guard a.count == b.count else { return 0 }
        
        let dotProduct = zip(a, b).map(*).reduce(0, +)
        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))
        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))
        
        guard magnitudeA > 0 && magnitudeB > 0 else { return 0 }
        
        return dotProduct / (magnitudeA * magnitudeB)
    }
}

// MARK: - SQLite Integration Tests

class SQLiteEmbeddingTests: XCTestCase {
    
    var sqliteService: SQLiteService!
    var embeddingService: EmbeddingService!
    
    override func setUp() {
        super.setUp()
        // Use in-memory database for tests
        sqliteService = try! SQLiteService(path: ":memory:", embeddingDimensions: 384)
        try! sqliteService.setupDatabase()
        embeddingService = try! EmbeddingService()
    }
    
    func testEmbeddingStorageRoundTrip() async {
        // Logic: Embeddings stored in SQLite should be identical when retrieved
        // Critical for search accuracy - any corruption breaks everything
        let text = "test document for storage"
        let originalEmbedding = try! await embeddingService.embed(text: text)
        
        let documentId = try! sqliteService.insertDocument(
            title: "Test",
            content: text,
            embedding: originalEmbedding
        )
        
        let retrievedDoc = try! sqliteService.findDocument(id: documentId)
        XCTAssertNotNil(retrievedDoc, "Should be able to retrieve stored document")
        
        // Note: This test assumes your SQLiteService can retrieve embeddings
        // You might need to add this functionality if it doesn't exist
    }
    
    func testVectorSearchOrdering() async {
        // Logic: Vector search should return results in correct similarity order
        // Critical for search relevance
        let query = "artificial intelligence"
        let queryEmbedding = try! await embeddingService.embed(text: query)
        
        // Insert documents with varying relevance
        let docs = [
            ("Highly Relevant", "artificial intelligence and machine learning"),
            ("Somewhat Relevant", "computer science and algorithms"),
            ("Not Relevant", "cooking recipes and food")
        ]
        
        for (title, content) in docs {
            let embedding = try! await embeddingService.embed(text: content)
            _ = try! sqliteService.insertDocument(title: title, content: content, embedding: embedding)
        }
        
        let results = try! sqliteService.searchDocuments(queryEmbedding: queryEmbedding, limit: 10)
        
        XCTAssertGreaterThanOrEqual(results.count, 3, "Should find all inserted documents")
        
        // Results should be ordered by distance (most similar first)
        for i in 0..<(results.count - 1) {
            XCTAssertLessThanOrEqual(results[i].distance, results[i + 1].distance,
                                   "Results should be ordered by increasing distance")
        }
        
        // Most relevant should be first
        XCTAssertEqual(results[0].document.title, "Highly Relevant",
                      "Most relevant document should be returned first")
    }
}

========== ./sqlite/constants.swift ==========
//
//  constants.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/25/25.
//
import Foundation
import Combine

/*
 FileManager.default.url(...) tries to get the path to the user's document directory.

 if that works, it appends "knowledge_base.sqlite" to it (i.e., creates a path like /Users/you/Documents/knowledge_base.sqlite)

 .path extracts the string path from the URL object.

 if any of that fails, it falls back to ":memory:", which is the SQLite special path for an in-memory db (non-persistent).
 
 for future could be useful to have some intermediate btwn in memory vs permanent, perhaps cache file or similar
 */
let defaultDBPath: String = {
    if let url = try? FileManager.default
        .url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true)
        .appendingPathComponent("knowledge_base.sqlite") {
        return url.path
    }
    return ":memory:"
}()

/// schema version to detect breaking changes
let schemaVersion = 2
// 2. bumped for new document tables
let databaseVersionKey = "dbSchemaVersion"


========== ./sqlite/Models/SearchResult.swift ==========
//
//  SearchResult.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/27/25.
//

import Foundation

struct SearchResult: Identifiable {
    let document: Document
    let distance: Double
    
    var id: Int32 { document.id }

    var similarity: Double {
        // inverse relationship between distance and similarity
        return max(0, 1.0 / (1.0 + distance))
    }
    
    /// formatted similarity percentage
    var similarityPercentage: String {
        return String(format: "%.1f%%", similarity * 100)
    }
}

========== ./sqlite/Models/Documents.swift ==========
//
//  Documents.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/27/25.
//

import Foundation

struct Document: Identifiable, Hashable {
    let id: Int32
    let title: String
    let content: String
    let createdAt: Date
    let embedding: [Float]?
    
    init(id: Int32, title: String, content: String, createdAt: Date = Date(), embedding: [Float]? = nil) {
        self.id = id
        self.title = title
        self.content = content
        self.createdAt = createdAt
        self.embedding = embedding
    }
}

extension Document {
    /// text to embed (title + content)
    var embeddableText: String {
        return "\(title)\n\n\(content)"
    }
    
    var preview: String {
        let maxLength = 200
        if content.count <= maxLength {
            return content
        }
        return String(content.prefix(maxLength)) + "..."
    }
}

========== ./sqlite/sqliteApp.swift ==========
//
//  sqliteApp.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/25/25.
//

import SwiftUI

@main
struct sqliteApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

========== ./sqlite/Views/ContentView.swift ==========
//
//  ContentView.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/25/25.
//
import SwiftUI

struct ContentView: View {
    @StateObject private var documentService = try! DocumentService()
     
    @State private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            DocumentView()
                .environmentObject(documentService)
                .tabItem {
                    Image(systemName: "doc.text")
                    Text("Documents")
                }
                .tag(0)
            
            SearchView()
                .environmentObject(documentService)
                .tabItem {
                    Image(systemName: "magnifyingglass")
                    Text("Search")
                }
                .tag(1)
        }
    }
}

struct DocumentView: View {
    @EnvironmentObject var documentService: DocumentService
    @State private var title = ""
    @State private var content = ""
    @State private var showingAddDocument = false
    
    var body: some View {
        NavigationView {
            VStack {
                if documentService.isLoading {
                    ProgressView("Processing...")
                        .padding()
                }
                
                if let error = documentService.error {
                    ErrorView(error: error) {
                        documentService.clearError()
                    }
                }
                
                List(documentService.documents) { document in
                    DocumentRowView(document: document)
                }
                .refreshable {
                    documentService.refresh()
                }
            }
            .navigationTitle("Knowledge Base")
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button("Add") {
                        showingAddDocument = true
                    } 
                }
            }
            .sheet(isPresented: $showingAddDocument) {
                AddDocumentView(
                    title: $title,
                    content: $content,
                    onSave: {
                        Task {
                            await documentService.addDocument(title: title, content: content)
                            title = ""
                            content = ""
                            showingAddDocument = false
                        }
                    },
                    onCancel: {
                        showingAddDocument = false
                    }
                )
            }
        }
    }
}

struct SearchView: View {
    @EnvironmentObject var documentService: DocumentService
    @State private var searchQuery = ""
    @State private var searchResults: [SearchResult] = []
    @State private var isSearching = false
    
    var body: some View {
        NavigationView {
            VStack {
                SearchBar(text: $searchQuery, onSearchButtonClicked: performSearch)
                
                if isSearching {
                    ProgressView("Searching...")
                        .padding()
                }
                
                List(searchResults) { result in
                    SearchResultRowView(result: result)
                }
            }
            .navigationTitle("Search")
        }
    }
    
    private func performSearch() {
        guard !searchQuery.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            return
        }
        
        isSearching = true
        Task {
            let results = await documentService.search(query: searchQuery)
            await MainActor.run {
                searchResults = results
                isSearching = false
            }
        }
    }
    
    
}

// MARK: - Supporting Views

struct DocumentRowView: View {
    let document: Document
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(document.title)
                .font(.headline)
            Text(document.preview)
                .font(.body)
                .foregroundColor(.secondary)
                .lineLimit(3)
            Text(document.createdAt.formatted(date: .abbreviated, time: .shortened))
                .font(.caption)
                .foregroundColor(.accentColor)
        }
        .padding(.vertical, 2)
    }
}

struct SearchResultRowView: View {
    let result: SearchResult
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(result.document.title)
                    .font(.headline)
                Spacer()
                Text(result.similarityPercentage)
                    .font(.caption)
                    .foregroundColor(.blue)
            }
            Text(result.document.preview)
                .font(.body)
                .foregroundColor(.secondary)
                .lineLimit(3)
        }
        .padding(.vertical, 2)
    }
}

struct AddDocumentView: View {
    @Binding var title: String
    @Binding var content: String
    let onSave: () -> Void
    let onCancel: () -> Void
    
    var body: some View {
        NavigationView {
            VStack(spacing: 16) {
                TextField("Title", text: $title)
                    .textFieldStyle(.roundedBorder)
                
                TextEditor(text: $content)
                    .border(Color.gray.opacity(0.3))
                
                Spacer()
            }
            .padding()
            .navigationTitle("Add Document")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel", action: onCancel)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save", action: onSave)
                        .disabled(title.isEmpty || content.isEmpty)
                }
            }
        }
    }
}

struct SearchBar: View {
    @Binding var text: String
    let onSearchButtonClicked: () -> Void
    
    var body: some View {
        HStack {
            TextField("Search your knowledge base...", text: $text)
                .textFieldStyle(.roundedBorder)
                .onSubmit {
                    onSearchButtonClicked()
                }
            
            Button("Search", action: onSearchButtonClicked)
                .disabled(text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
        }
        .padding(.horizontal)
    }
}

struct ErrorView: View {
    let error: Error
    let onDismiss: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: "exclamationmark.triangle")
                .foregroundColor(.red)
            Text(error.localizedDescription)
                .font(.caption)
            Spacer()
            Button("Dismiss", action: onDismiss)
                .font(.caption)
        }
        .padding()
        .background(Color.red.opacity(0.1))
        .cornerRadius(8)
        .padding(.horizontal)
    }
}

#Preview {
    ContentView()
}

========== ./sqlite/Services/EmbeddingService.swift ==========
//
//  EmbeddingService.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/27/25.

//  BertTokenizer.swift
//  sqlite
//
//  Adapted from HuggingFace CoreMLBert

import Foundation
import CoreML

// MARK: - Utils Helper
class Utils {
    static func substr(_ str: String, _ range: Range<Int>) -> String? {
        guard range.lowerBound >= 0 && range.upperBound <= str.count else { return nil }
        let start = str.index(str.startIndex, offsetBy: range.lowerBound)
        let end = str.index(str.startIndex, offsetBy: range.upperBound)
        return String(str[start..<end])
    }
}

// MARK: - Tokenization Result
struct TokenizationResult {
    let inputIds: [Int]
    let attentionMask: [Int]
}

// MARK: - BERT Tokenizer
enum TokenizerError: Error {
    case tooLong(String)
    case vocabNotFound
}

class BertTokenizer {
    private let basicTokenizer = BasicTokenizer()
    private let wordpieceTokenizer: WordpieceTokenizer
    private let maxLen = 512
    
    private let vocab: [String: Int]
    private let ids_to_tokens: [Int: String]
    
    init() throws {
        guard let url = Bundle.main.url(forResource: "vocab", withExtension: "txt") else {
            throw TokenizerError.vocabNotFound
        }
        let vocabTxt = try String(contentsOf: url, encoding: .utf8)
        let tokens = vocabTxt.split(separator: "\n").map { String($0) }
        
        var vocab: [String: Int] = [:]
        var ids_to_tokens: [Int: String] = [:]
        for (i, token) in tokens.enumerated() {
            vocab[token] = i
            ids_to_tokens[i] = token
        }
        self.vocab = vocab
        self.ids_to_tokens = ids_to_tokens
        self.wordpieceTokenizer = WordpieceTokenizer(vocab: self.vocab)
    }
    
    func tokenize(text: String) -> [String] {
        var tokens: [String] = []
        for token in basicTokenizer.tokenize(text: text) {
            for subToken in wordpieceTokenizer.tokenize(word: token) {
                tokens.append(subToken)
            }
        }
        return tokens
    }
    
    private func convertTokensToIds(tokens: [String]) throws -> [Int] {
        if tokens.count > maxLen {
            throw TokenizerError.tooLong(
                "Token sequence length (\(tokens.count)) exceeds maximum length (\(maxLen))"
            )
        }
        return tokens.compactMap { vocab[$0] }
    }
    
    /// Main entry point for sentence transformer models
    func encode(text: String, maxLength: Int = 512) throws -> TokenizationResult {
        // Tokenize the text
        let tokens = tokenize(text: text)
        
        // Add special tokens: [CLS] + tokens + [SEP]
        let specialTokens = ["[CLS]"] + tokens + ["[SEP]"]
        
        // Convert to IDs
        let tokenIds = try convertTokensToIds(tokens: specialTokens)
        
        // Truncate if needed
        let truncatedIds = Array(tokenIds.prefix(maxLength))
        
        // Create attention mask (1 for real tokens, 0 for padding)
        let realTokenCount = truncatedIds.count
        let attentionMask = Array(repeating: 1, count: realTokenCount) +
                          Array(repeating: 0, count: maxLength - realTokenCount)
        
        // Pad input IDs to maxLength
        let paddedIds = truncatedIds + Array(repeating: 0, count: maxLength - realTokenCount)
        
        return TokenizationResult(inputIds: paddedIds, attentionMask: attentionMask)
    }
    
    func tokenToId(token: String) -> Int {
        return vocab[token] ?? vocab["[UNK]"] ?? 0
    }
    
    func unTokenize(tokens: [Int]) -> [String] {
        return tokens.compactMap { ids_to_tokens[$0] }
    }
}

// MARK: - Basic Tokenizer
class BasicTokenizer {
    let neverSplit = [
        "[UNK]", "[SEP]", "[PAD]", "[CLS]", "[MASK]"
    ]
    
    func tokenize(text: String) -> [String] {
        let splitTokens = text.folding(options: .diacriticInsensitive, locale: nil)
            .components(separatedBy: NSCharacterSet.whitespaces)
        let tokens = splitTokens.flatMap({ (token: String) -> [String] in
            if neverSplit.contains(token) {
                return [token]
            }
            var toks: [String] = []
            var currentTok = ""
            for c in token.lowercased() {
                if c.isLetter || c.isNumber || c == "¬∞" {
                    currentTok += String(c)
                } else if currentTok.count > 0 {
                    toks.append(currentTok)
                    toks.append(String(c))
                    currentTok = ""
                } else {
                    toks.append(String(c))
                }
            }
            if currentTok.count > 0 {
                toks.append(currentTok)
            }
            return toks
        })
        return tokens.filter { !$0.isEmpty }
    }
}

// MARK: - Wordpiece Tokenizer
class WordpieceTokenizer {
    private let unkToken = "[UNK]"
    private let maxInputCharsPerWord = 100
    private let vocab: [String: Int]
    
    init(vocab: [String: Int]) {
        self.vocab = vocab
    }
    
    func tokenize(word: String) -> [String] {
        if word.count > maxInputCharsPerWord {
            return [unkToken]
        }
        var outputTokens: [String] = []
        var isBad = false
        var start = 0
        var subTokens: [String] = []
        while start < word.count {
            var end = word.count
            var cur_substr: String? = nil
            while start < end {
                guard var substr = Utils.substr(word, start..<end) else { break }
                if start > 0 {
                    substr = "##\(substr)"
                }
                if vocab[substr] != nil {
                    cur_substr = substr
                    break
                }
                end -= 1
            }
            if cur_substr == nil {
                isBad = true
                break
            }
            subTokens.append(cur_substr!)
            start = end
        }
        if isBad {
            outputTokens.append(unkToken)
        } else {
            outputTokens.append(contentsOf: subTokens)
        }
        return outputTokens
    }
}

// MARK: - Updated EmbeddingService
enum EmbeddingError: Error {
    case modelNotFound
    case modelLoadFailed(Error)
    case predictionFailed(Error)
    case invalidOutput
    case invalidInput
    case tokenizerInitFailed
}

final class EmbeddingService {
    private let tokenizer: BertTokenizer
    private let model: all_MiniLM_L6_v2
    
    /// dimensions of the embedding output
    let embeddingDimensions: Int
    
    init() throws {
        // Initialize tokenizer
        do {
            self.tokenizer = try BertTokenizer()
        } catch {
            throw EmbeddingError.tokenizerInitFailed
        }
        
        // Load CoreML model using auto-generated class
        do {
            self.model = try all_MiniLM_L6_v2(configuration: MLModelConfiguration())
        } catch {
            throw EmbeddingError.modelLoadFailed(error)
        }
        
        self.embeddingDimensions = 384
    }
    
    /// generate embedding for text
    func embed(text: String) async throws -> [Float] {
        return try await withCheckedThrowingContinuation { continuation in
            Task {
                do {
                    let embedding = try await generateEmbedding(for: text)
                    continuation.resume(returning: embedding)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    
    /// generate embeddings for multiple texts (batch processing)
    func embed(texts: [String]) async throws -> [[Float]] {
        var embeddings: [[Float]] = []
        for text in texts {
            let embedding = try await embed(text: text)
            embeddings.append(embedding)
        }
        return embeddings
    }
    
    private func generateEmbedding(for text: String) async throws -> [Float] {
        // Tokenize the input text
        let tokenizationResult = try tokenizer.encode(text: text, maxLength: 512)
        
        // Create MLMultiArray for input_ids
        guard let inputIdsArray = try? MLMultiArray(shape: [1, 512], dataType: .float32) else {
            throw EmbeddingError.invalidInput
        }
        
        // Create MLMultiArray for attention_mask
        guard let attentionMaskArray = try? MLMultiArray(shape: [1, 512], dataType: .float32) else {
            throw EmbeddingError.invalidInput
        }
        
        // Fill the arrays
        for i in 0..<512 {
            inputIdsArray[i] = NSNumber(value: Float(tokenizationResult.inputIds[i]))
            attentionMaskArray[i] = NSNumber(value: Float(tokenizationResult.attentionMask[i]))
        }
        
        // Run inference using the auto-generated class
        do {
            let output = try model.prediction(input_ids: inputIdsArray, attention_mask: attentionMaskArray)
            
            // Extract embeddings from the output
            let embeddingsMultiArray = output.embeddings
            
            // Convert MLMultiArray to [Float]
            var embeddings: [Float] = []
            let count = embeddingsMultiArray.count
            for i in 0..<count {
                embeddings.append(embeddingsMultiArray[i].floatValue)
            }
            
            return embeddings
            
        } catch {
            throw EmbeddingError.predictionFailed(error)
        }
    }
}

========== ./sqlite/Services/DocumentService.swift ==========
//
//  DocumentService.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/27/25.
//
import Foundation
import Combine

enum DocumentServiceError: Error {
    case embeddingFailed(Error)
    case storageFailed(Error)
    case searchFailed(Error)
    case serviceUnavailable
}

@MainActor
final class DocumentService: ObservableObject {
    @Published private(set) var documents: [Document] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    private let sqliteService: SQLiteService
    private let embeddingService: EmbeddingService
    
    init() throws {
        self.embeddingService = try EmbeddingService()
        self.sqliteService = try SQLiteService(embeddingDimensions: embeddingService.embeddingDimensions)
        
        // setup database
        try sqliteService.setupDatabase()
        
        // load initial documents
        refresh()
    }
    
    
    
    // MARK: - Document Management
    
    func addDocument(title: String, content: String) async {
        isLoading = true
        error = nil
        
        do {
            // generate embedding
            let text = "\(title)\n\n\(content)"
            let embedding = try await embeddingService.embed(text: text)
            
            // store document with embedding
            let documentId = try sqliteService.insertDocument(
                title: title,
                content: content,
                embedding: embedding
            )
            
            // refresh document list
            refresh()
            
        } catch {
            self.error = DocumentServiceError.embeddingFailed(error)
        }
        
        isLoading = false
    }
    
    func refresh() {
        Task {
            do {
                let docs = try sqliteService.findAllDocuments()
                await MainActor.run {
                    documents = docs
                }
            } catch {
                await MainActor.run {
                    self.error = DocumentServiceError.storageFailed(error)
                }
            }
        }
    }
    
    // MARK: - Search
    
    func search(query: String, limit: Int = 10) async -> [SearchResult] {
        guard !query.isEmpty else { return [] }
        
        do {
            let queryEmbedding = try await embeddingService.embed(text: query)
            
            let results = try sqliteService.searchDocuments(
                queryEmbedding: queryEmbedding,
                limit: limit
            )
            
            return results
        } catch {
            await MainActor.run {
                self.error = DocumentServiceError.searchFailed(error)
            }
            return []
        }
        
        
    }
    
    // MARK: - Batch Operations
    
    func addDocuments(_ documents: [(title: String, content: String)]) async {
        isLoading = true
        error = nil
        
        do {
            // batch embed all documents
            let texts = documents.map { "\($0.title)\n\n\($0.content)" }
            let embeddings = try await embeddingService.embed(texts: texts)
            
            // store all documents
            for (i, doc) in documents.enumerated() {
                _ = try sqliteService.insertDocument(
                    title: doc.title,
                    content: doc.content,
                    embedding: embeddings[i]
                )
            }
            
            refresh()
            
        } catch {
            self.error = DocumentServiceError.embeddingFailed(error)
        }
        
        isLoading = false
    }
    
    // MARK: - Document Retrieval
    
    func getDocument(id: Int32) -> Document? {
        return documents.first { $0.id == id }
    }
    
    func getDocuments(containing text: String) -> [Document] {
        let searchText = text.lowercased()
        return documents.filter { doc in
            doc.title.lowercased().contains(searchText) ||
            doc.content.lowercased().contains(searchText)
        }
    }
    
    // MARK: - Error Handling
    
    func clearError() {
        error = nil
    }
}

========== ./sqlite/Services/SQLiteService.swift ==========
//
//  SQLiteService.swift
//  sqlite
//
//  Created by Mordecai Mengesteab on 5/25/25.
//
import Foundation
import SQLite3

enum SQLiteError: Error {
    case openDatabase(message: String)
    case prepare(message: String)
    case step(message: String)
    case bind(message: String)
    case initExtension(message: String)
}

final class SQLiteService {
    private let dbPointer: OpaquePointer?
    private let embeddingDimensions: Int
    
    init(path: String = defaultDBPath, embeddingDimensions: Int = 384) throws {
        self.embeddingDimensions = embeddingDimensions
        
        // migrate-destroy if schema version changed
        let defaults = UserDefaults.standard
        let previous = defaults.integer(forKey: databaseVersionKey)
        if previous != schemaVersion {
            try? FileManager.default.removeItem(atPath: path)
            defaults.set(schemaVersion, forKey: databaseVersionKey)
        }

        var db: OpaquePointer?
        if sqlite3_open(path, &db) == SQLITE_OK {
            self.dbPointer = db
            
            // load sqlite-vec extension
            if sqlite3_vec_init(db, nil, nil) != SQLITE_OK {
                let msg = String(cString: sqlite3_errmsg(db))
                throw SQLiteError.initExtension(message: msg)
            }
        } else {
            defer { if db != nil { sqlite3_close(db) } }
            let msg = db.flatMap { String(cString: sqlite3_errmsg($0)) } ?? "no error"
            throw SQLiteError.openDatabase(message: msg)
        }
    }

    deinit {
        sqlite3_close(dbPointer)
    }

    private var errorMessage: String {
        if let ptr = sqlite3_errmsg(dbPointer) {
            return String(cString: ptr)
        }
        return "no error"
    }

    private func prepare(_ sql: String) throws -> OpaquePointer? {
        var stmt: OpaquePointer?
        guard sqlite3_prepare_v2(dbPointer, sql, -1, &stmt, nil) == SQLITE_OK else {
            throw SQLiteError.prepare(message: errorMessage)
        }
        return stmt
    }

    func execute(_ sql: String) throws {
        let stmt = try prepare(sql)
        defer { sqlite3_finalize(stmt) }
        guard sqlite3_step(stmt) == SQLITE_DONE else {
            throw SQLiteError.step(message: errorMessage)
        }
    }
    
    // MARK: - Database Setup
    
    func setupDatabase() throws {
        // create documents table
        let documentsSQL = """
        CREATE TABLE IF NOT EXISTS Document(
            Id INTEGER PRIMARY KEY AUTOINCREMENT,
            Title TEXT NOT NULL,
            Content TEXT NOT NULL,
            CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        """
        try execute(documentsSQL)
        
        // create vector table for embeddings
        let vectorSQL = "CREATE VIRTUAL TABLE IF NOT EXISTS DocumentEmbedding USING vec0(embedding float[\(embeddingDimensions)]);"
        try execute(vectorSQL)
        
        // legacy contact table
        let contactSQL = """
        CREATE TABLE IF NOT EXISTS Contact(
            Id INTEGER PRIMARY KEY AUTOINCREMENT,
            Name TEXT NOT NULL
        );
        """
        try execute(contactSQL)
    }
    
    // MARK: - Document Operations
    
    func insertDocument(title: String, content: String, embedding: [Float]) throws -> Int32 {
        // insert document
        let docSQL = "INSERT INTO Document (Title, Content) VALUES (?, ?);"
        let stmt = try prepare(docSQL)
        defer { sqlite3_finalize(stmt) }

        let SQLITE_TRANSIENT = unsafeBitCast(-1, to: sqlite3_destructor_type.self)
        guard sqlite3_bind_text(stmt, 1, title, -1, SQLITE_TRANSIENT) == SQLITE_OK,
              sqlite3_bind_text(stmt, 2, content, -1, SQLITE_TRANSIENT) == SQLITE_OK else {
            throw SQLiteError.bind(message: errorMessage)
        }
        guard sqlite3_step(stmt) == SQLITE_DONE else {
            throw SQLiteError.step(message: errorMessage)
        }
        
        let documentId = sqlite3_last_insert_rowid(dbPointer)
        
        // insert embedding with same rowid using vec_f32()
        try insertEmbedding(rowid: Int32(documentId), embedding: embedding)
        
        return Int32(documentId)
    }
    
    func findDocument(id: Int32) throws -> Document? {
        let sql = "SELECT Id, Title, Content, CreatedAt FROM Document WHERE Id = ?;"
        let stmt = try prepare(sql)
        defer { sqlite3_finalize(stmt) }
        
        guard sqlite3_bind_int(stmt, 1, id) == SQLITE_OK else {
            throw SQLiteError.bind(message: errorMessage)
        }
        
        if sqlite3_step(stmt) == SQLITE_ROW {
            return extractDocument(from: stmt)
        }
        return nil
    }
    
    func findAllDocuments() throws -> [Document] {
        let sql = "SELECT Id, Title, Content, CreatedAt FROM Document ORDER BY CreatedAt DESC;"
        let stmt = try prepare(sql)
        defer { sqlite3_finalize(stmt) }

        var documents = [Document]()
        while sqlite3_step(stmt) == SQLITE_ROW {
            documents.append(extractDocument(from: stmt))
        }
        return documents
    }
    
    
    func searchDocuments(queryEmbedding: [Float], limit: Int = 10) throws -> [SearchResult] {
        // first get matching rowids and distances
        let vectorSQL = "SELECT rowid, distance FROM DocumentEmbedding WHERE embedding MATCH vec_f32(?) ORDER BY distance LIMIT ?;"
        
        let stmt = try prepare(vectorSQL)
        defer { sqlite3_finalize(stmt) }
        
        let vectorBlob = embeddingToBlob(queryEmbedding)
        
        guard sqlite3_bind_blob(stmt, 1, vectorBlob, Int32(vectorBlob.count), nil) == SQLITE_OK,
              sqlite3_bind_int(stmt, 2, Int32(limit)) == SQLITE_OK else {
            throw SQLiteError.bind(message: errorMessage)
        }
        
        var results = [SearchResult]()
        while sqlite3_step(stmt) == SQLITE_ROW {
            let rowid = sqlite3_column_int(stmt, 0)
            let distance = sqlite3_column_double(stmt, 1)
            
            // fetch the actual document by id
            if let document = try findDocument(id: rowid) {
                results.append(SearchResult(document: document, distance: distance))
            }
        }
        
        print("total results: \(results.count)")
        return results
    }
    
    // MARK: - Private Helpers
    
    private func insertEmbedding(rowid: Int32, embedding: [Float]) throws {
        // use vec_f32() to convert blob to proper vector
        let sql = "INSERT INTO DocumentEmbedding(rowid, embedding) VALUES (?, vec_f32(?));"
        let stmt = try prepare(sql)
        defer { sqlite3_finalize(stmt) }
        
        let vectorBlob = embeddingToBlob(embedding)
        
        guard sqlite3_bind_int(stmt, 1, rowid) == SQLITE_OK,
              sqlite3_bind_blob(stmt, 2, vectorBlob, Int32(vectorBlob.count), nil) == SQLITE_OK else {
            throw SQLiteError.bind(message: errorMessage)
        }
        guard sqlite3_step(stmt) == SQLITE_DONE else {
            throw SQLiteError.step(message: errorMessage)
        }
    }
    
    /// convert [Float] to binary blob (4 bytes per float, little endian)
    private func embeddingToBlob(_ embedding: [Float]) -> [UInt8] {
        var blob = [UInt8]()
        blob.reserveCapacity(embedding.count * 4)
        
        for value in embedding {
            let bits = value.bitPattern
            blob.append(UInt8(bits & 0xFF))
            blob.append(UInt8((bits >> 8) & 0xFF))
            blob.append(UInt8((bits >> 16) & 0xFF))
            blob.append(UInt8((bits >> 24) & 0xFF))
        }
        
        return blob
    }
    
    private func extractDocument(from stmt: OpaquePointer?) -> Document {
        let id = sqlite3_column_int(stmt, 0)
        let title = String(cString: sqlite3_column_text(stmt, 1))
        let content = String(cString: sqlite3_column_text(stmt, 2))
        
        // parse date
        let dateString = String(cString: sqlite3_column_text(stmt, 3)) 
        let formatter = ISO8601DateFormatter()
        let date = formatter.date(from: dateString) ?? Date()
        
        return Document(id: id, title: title, content: content, createdAt: date)
    }
}

========== ./sqliteUITests/sqliteUITests.swift ==========
//
//  sqliteUITests.swift
//  sqliteUITests
//
//  Created by Mordecai Mengesteab on 5/25/25.
//

import XCTest

final class sqliteUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it‚Äôs important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
            // This measures how long it takes to launch your application.
            measure(metrics: [XCTApplicationLaunchMetric()]) {
                XCUIApplication().launch()
            }
        }
    }
}

========== ./sqliteUITests/sqliteUITestsLaunchTests.swift ==========
//
//  sqliteUITestsLaunchTests.swift
//  sqliteUITests
//
//  Created by Mordecai Mengesteab on 5/25/25.
//

import XCTest

final class sqliteUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}

